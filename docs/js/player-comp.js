import{TIMEOUT_BG,TIMEOUT_SM}from"./info.js";import{Player}from"./player.js";import{drawCluster,drawDices}from"./draw.js";class Comp extends Player{constructor(){super()}async turn(s,t,i){super.turn();let d=s.filter(e=>e.playerId===this.id&&1<e.dices).sort((e,r)=>r.dices-e.dices),c=d.shift();for(;void 0!==c;){var e=this.mightyOther(s,t);let r=this.target(c,e);void 0===r?c=d.shift():await this.attack(c,r).then(e=>{void 0===e?c=d.shift():(c=r,this.afterSuccessfulMove(s,t,e)&&(c=void 0,i=()=>{}))})}i()}mightyOther(s,r){var e=r.map(e=>({id:e.id,dices:e.dices+e.additionalDices,clusters:0,obj:e}));let t=0;for(let r of s)t+=r.dices,e.find(e=>e.id===r.playerId).clusters++;var i=e.find(e=>e.dices>=2.5*Math.floor(t/r.length)||e.clusters>=2.5*Math.floor(s.length/r.length));if(void 0!==i&&i.id!==this.id)return i.obj}target(r,s){let e=r.getAdjacentClustersFromCluster().filter(e=>e.playerId!==this.id);var t,i=(e=(e=void 0!==s?e.filter(e=>e.playerId===s.id):e).filter(e=>r.dices>e.dices-(8===r.dices))).reduce((e,r)=>((e[r.dices]=e[r.dices]||[]).push(r),e),{});let d=[...Array(r.dices-1).keys()].sort((e,r)=>r-e).slice(0,r.dices-2).concat([r.dices-1]);for(t of d=8===r.dices?d.concat([8]):d)if(t in i)return i[t][0]}paths(e){if(e.length!==this.dices)return[]}attack(d,c){return new Promise(s=>{let t=Player.roleDice(d.dices),i=Player.roleDice(c.dices);console.log(`attacks ${c.playerId} -> thrown dices: ${t} vs `+i),drawCluster(d.corners),setTimeout(()=>{drawCluster(c.corners),setTimeout(()=>{var e,r=d.dices;d.dices=1,drawDices(d),drawCluster(d.corners,this.id),t>i?(e=c.playerId,c.playerId=this.id,c.dices=r-1,drawDices(c),drawCluster(c.corners,this.id),s(e)):(drawCluster(c.corners,c.playerId),s(void 0))},TIMEOUT_BG)},TIMEOUT_SM)})}}export{Comp};