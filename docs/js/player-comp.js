import{TIMEOUT_BG,TIMEOUT_SM}from"./info.js";import{Player}from"./player.js";import{drawCluster,drawDices}from"./draw.js";class Comp extends Player{constructor(e){super(e)}async turn(r,t,e,i){super.turn();let s=this.path(r),a=this.mightyOthers(r,t);for(;s&&(0===a.length||a[0].dices<=r.length/2||s.slice(1,-1).every(e=>e.playerId===a[0].id));){let e=s.shift();for(var l of s.slice(0,-1)){var d=await this.attack(e,l);if(void 0===d)break;if(this.afterSuccessfulMove(r,t,d))return void await i(!1);e=l}s=this.path(r),a=this.mightyOthers(r,t)}var o=r.filter(e=>e.playerId===this.id&&1<e.dices).sort((e,r)=>r.dices-e.dices);let h=o.shift();for(;h;){a=this.mightyOthers(r,t);var f=this.target(h,a);if(f){var c=await this.attack(h,f);if(void 0===c)h=o.shift();else{if(this.afterSuccessfulMove(r,t,c))return void await i(!1);h=1<f.dices?f:o.shift()}}else h=o.shift()}e()}attack(a,l){return new Promise(t=>{let i=Player.roleDice(a.dices),s=Player.roleDice(l.dices);console.log(`attacks ${l.playerId}: ${a.id} vs ${l.id} -> thrown dices: ${i} vs `+s),drawCluster(a.corners),setTimeout(()=>{drawCluster(l.corners),setTimeout(()=>{var e,r=a.dices;a.dices=1,drawDices(a),drawCluster(a.corners,this.id),i>s?(e=l.playerId,l.playerId=this.id,l.dices=r-1,drawDices(l),drawCluster(l.corners,this.id),t(e)):(drawCluster(l.corners,l.playerId),t(void 0))},TIMEOUT_BG)},TIMEOUT_SM)})}mightyOthers(e,r){let t=Math.floor(e.length/3);return r.filter(e=>e.id!==this.id&&e.dices>t).sort((e,r)=>r.dices-e.dices)}target(r,t){let i=r.adjacentClustersFromCluster().filter(e=>e.playerId!==this.id);if(0<t.length){let e;for(let r of t)if(0<(e=i.filter(e=>e.playerId===r.id)).length)break;i=e}if(0!==(i=i.filter(e=>r.dices>e.dices-(8===r.dices))).length){var e,s=i.reduce((e,r)=>((e[r.dices]=e[r.dices]||[]).push(r),e),{}),t=[...Array(r.dices-1).keys()].reverse();t[t.length-1]=r.dices-1,8===r.dices&&t.push(8);for(e of t)if(e in s)return s[e][Math.floor(Math.random()*s[e].length)]}}path(e){let r=[];for(var t of e.filter(e=>e.playerId===this.id))r.flat().includes(t)||r.push(t.region());let i;for(var[s,a]of(r=r.map(e=>e.filter(e=>e.adjacentClustersFromCluster().some(e=>e.playerId!==this.id)))).entries())for(var l of a)for(var[d,o]of r.entries())if(a!==o)for(var h of o){var f,c,h=l.path(h);h&&(!i||(f=a.length+o.length,(c=r[i.from].length+r[i.to].length)<f)||f===c&&h.length<i.path.length)&&(i={from:s,to:d,path:h})}return i?.path}}export{Comp};